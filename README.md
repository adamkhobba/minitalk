# minitalk
Minitalk is a new project and challenge for me 
# Process vs Program
## Process
**`Process`** : is an instance of an executing program.
[More details] : a process is an abstract entity, defined by the kernel, to which system resources are allocated in order to execute a program.
## Program
### Definition
**`Progam`** : is a file contain a range of information which will describe how to construct a process at run time.

`This information includes the following:`
### Binary format identification
this enables the kernel to interpret the remaining information in the file.
And that include the binary files.
>[!info]
>a.out => (assembler output)
### Machine-language instructions
these encode the algorithm of the program.
### Program entry-point address
this identifies the location of the instruction at which execution of the program should commence.
### Data
the program file contains the values of variables and also literal constants used by program.
### Symbol and relocation tables
#### Symbol table
the symbol table is a data structure used by the linker to keep track of symbols defined in the program.
this table include information such as the symbol's name, it's size ,its location in memory, and other relevant attributes.
#### Relocation table
Relocation table is also a data structure used by the liker to perform 
address adjustments or relocations on the machine code generated by the compiler.
Relocation entries in the relocation table specify the locations and types of adjustments needed for each symbol reference in the machine code.
### Shared-library and dynamic-linking information
**`Shared-library`**  : the program file include the libraries which the program will use.
**`Dynamic-linking`** : Dynamic linking is a mechanism used to link programs with shared libraries at runtime.
### ...
## Process ID vs Parent Process ID
**`Process ID`** : is a positive integer that uniquely identifies the process on the system 
**`Parent Process ID`** : is a integer the parent of each process has its own parent, and so on, going all the way back to process 1.
## Memory layout 
###  etext , edata, end 
these symbols can be used from within a program to obtain the addresses of the next byte past, respectively **`etext`** : the end of the program text, **`edata`** the end of the initialized data segment, **`end`** and the end of the uninitialized data segment.
## Virtual Memory Management
**`virtual Memory  Management`** : The aim of this technique is to make efficient use of both the CPU and  RAM (physical memory) by exploiting a property that is typical of most programs.
### Locality of reference
**`Locality of reference`** : refers to the tendency of programs to access memory or data within localized regions rather than scattered throughout the memory space.
#### Spatial locality :
This refers to the tendency of a program to access memory locations that are close to each other in space.
#### Temporal  locality : 
This refers to the tendency of a program to access memory locations that are close to each other in space.
###  Pages 
**Page size** : from 4KB to 64KB

**Page fault** : when a  program tries to access the memory address not currently in RAM but in the hard disk. 
**Page table** : is a data structure to map virtual addresses used by the programs to physical addresses in RAM or disk storage.  
###


# Extra Knowledge 
## ABI
**`ABI`** : stands for Application Binary Interface. It is a low-level interface between a program and the operating system or between different software components within a program. The ABI defines how functions, data structures, and system calls are represented in binary form, allowing different software components to communicate with each other regardless of the programming languages they were written in or the hardware architectures they run on.
# functions
## Process
A process is 
## Getpid
#getpid
### Description
**\# include <unistd.h>**
this function return the Process id of the current process during its run.
### Prototype
```c
getpid();
```
### Return
Process id.
## Sleep
#sleep
### Description
**\# include<unistd.h>**
Sleep pause the process a specified amount of time. And it can take as parameter an integer plus a character like'm' for minutes, 'h' for hours or 'd' for days.
### Prototype
```c
sleep(time_of_sleeping);
```
### Return 
Zero if the requested time has elapsed(done), or the number of seconds left to sleep, if the call was interrupted by a signal handler.
## Usleep
#usleep
>[!info]
it's like sleep but in the microseconds.

## Signal
#signal
### Description
**\#include <signal.h>**
The C library function void (\*signal(int sig, void (\*func)(int)))(int) sets a function to handle signal i.e. a signal handler with signal number sig.
### Prototype
```c
void (*signal(int sig, void (*func)(int)))(int)
```
### Return 
This function returns the previous value of the signal handler, or SIG_ERR on error.
## kill
#kill
### Description 
**#include <signal.h>**

### Prototype
```c
int kill(pid_t pid, int sig);
```
### Return 
it's return 0 in success , and -1 in error, and errno is set to indicate the error. 
## sigaction
#sigactio
### Description
Examines and changes the action associated with a specific signal.

int sig is the number of a recognized signal. sigaction() examines and sets the action to be associated with this signal. See Table 1 for the values of sig, as well as the signals supported by z/OSÂ® UNIX services. The sig argument must be one of the macros defined in the signal.h header file.

const struct sigaction *new may be a NULL pointer. If so, sigaction() merely determines the action currently defined to handle sig. It does not change this action. If new is not NULL, it should point to a sigaction structure. The action specified in this structure becomes the new action associated with sig.

struct sigaction *old points to a memory location where sigaction() can store a sigaction structure. sigaction() uses this memory location to store a sigaction structure describing the action currently associated with sig. old can also be a NULL pointer, in which case sigaction() does not store this information.

This function is supported only in a POSIX program.
#### SA_SIGINFO 
##### si_signo
Contains the system-generated signal number
##### si_errno
Contains the implementation-specific error information (it is not used on this implementation)
##### si_code
Contains a code identifying the cause of the signal (refer to the <signal.h> include file for a list of these codes and for their meanings, see Table 1).
If si_signo contains SIGPOLL then si_code can be set to SI_ASYNCIO. Otherwise, if the value of si_code is less than or equal to zero then the signal was generated by another process and the si_pid and si_uid members respectively indicate the process ID and the real user ID of the sender of this signal.

If the value of si_code is less than or equal to zero, then the signal was generated by another process and the si_pid and si_uid members respectively indicate the process ID and the real user ID of the sender of this signal.
##### si_pid
If the value of si_code is less than or equal to zero, then this member will indicate the process ID of the sender of this signal. Otherwise, this member is meaningless.
##### si_uid
If the value of si_code is less than or equal to zero, then this member will indicate the real user ID of the sender of this signal. Otherwise, this member is meaningless.
##### si_value
If si_code is SI_ASYNCIO, si_value contains the application specified value. Otherwise, the contents of si_value are undefined

### Prototype
```c
int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact);
```
### Return

If successful, sigaction() returns 0.

If unsuccessful, no new signal handler is installed, sigaction() returns -1, errno .
# Resources
**sigaction** : https://www.ibm.com/docs/en/zos/3.1.0?topic=functions-sigaction-examine-change-signal-action

**stackoverflow** : https://stackoverflow.com/questions/25663492/user-defined-signal-1



# Resources
- The Linux Programming interface
